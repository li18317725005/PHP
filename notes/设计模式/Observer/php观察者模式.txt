观察者模式(发布-订阅（Publish-Subscribe）模式、模型-视图（Model-View）模式、源-监听（Source-Listener）模式、或从属者(Dependents)模式)

介绍:
观察者模式是挺常见的一种设计模式，使用得当会给程序带来非常大的便利，使用得不当，会给后来人一种难以维护的想法．
一个对象（被观察者）给其他对象（观察者）提供注册接口，当被观察者发生改变时，通知观察者页进行改变
观察者模式定义对象一对多依赖，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新!

1. 找出程序中会变化的方面，然后将其和固定不变的方面相分离!

在观察者模式中，会改变的是主题的状态以及观察者的数目。用这个模式，你可以改变依赖于主题状态的对象，却不必改变主题。

2. 针对接口编程，不针对实现编程!

主题和观察者都使用接口:观察者利用主题的接口向主题注册，而主题利用观察者接口通知观察者。这样可以让两者之间运作正常，又同时具有松耦合的优点! 

3. 多用组合，少用继承！

观察者模式利用“组合”将许多观察者组合进主题中。对象(观察者――主题)之间的这种关系不是通过继承产生的，而是在运行时利用组合的方式产生的。


【观察者模式中主要角色】
1.抽象主题（Subject）角色：主题角色将所有对观察者对象的引用保存在一个集合中，每个主题可以有任意多个观察者。 抽象主题提供了增加和删除观察者对象的接口。
2.抽象观察者（Observer）角色：为所有的具体观察者定义一个接口，在观察的主题发生改变时更新自己。
3.具体主题（ConcreteSubject）角色：存储相关状态到具体观察者对象，当具体主题的内部状态改变时，给所有登记过的观察者发出通知。具体主题角色通常用一个具体子类实现。
4.具体观察者（ConcretedObserver）角色：存储一个具体主题对象，存储相关状态，实现抽象观察者角色所要求的更新接口，以使得其自身状态和主题的状态保持一致。

【观察者模式的优点和缺点】
观察者模式的优点：
1.观察者和主题之间的耦合度较小；
2.观察者模式支持广播通讯。被观察者会向所有的登记过的观察者发出通知，；
观察者模式的缺点：
1. 如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。
2. 如果在被观察者之间有循环依赖的话，被观察者会触发它们之间进行循环调用，导致系统崩溃。在使用观察者模式是要特别注意这一点。
3. 虽然观察者模式可以随时使观察者知道所观察的对象发生了变化，但是观察者模式没有相应的机制使观察者知道所观察的对象是怎么发生变化的。

【观察者模式适用场景】
当一个抽象模型有两个方面，其中一个方面依赖于另一个方面。
当对一个对象的改变需要同时改变其它对象，而不知道具体有多少个对象待改变。
当一个对象必须通知其它对象，而它又不能假定其它对象是谁。换句话说，你不希望这些对象是紧密耦合的。

实例:
 * 场景描述：
 * 汪特目前以购票为核心业务(此模式不限于该业务)，但围绕购票会产生不同的其他逻辑，如：
 * 1、购票后记录文本日志
 * 2、购票后记录数据库日志
 * 3、购票后发送短信/消息
 * 4、购票送抵扣卷、兑换卷、积分
 * 5、其他操作等
 *
 * 传统解决方案:
 * 在购票逻辑等类内部增加相关代码，完成各种逻辑。
 *
 * 存在问题：
 * 1、一旦某个业务逻辑发生改变，如购票业务中增加其他业务逻辑，需要修改购票核心文件、甚至购票流程。
 * 2、日积月累后，文件冗长，导致后续维护困难。
 *
 * 存在问题原因主要是程序的"紧密耦合"，使用观察模式将目前的业务逻辑优化成"松耦合"，达到易维护、易修改的目的，
 * 同时也符合面向接口编程的思想。


拓展:
Php提供了SplObjectStorage类，这个类提升了观察者模式的可用性。这个类与数组相似。但它只能存储具有唯一性的对象，而且只存储这些对象的引用。
SplObjectStorage是SPL标准库中的数据结构对象容器,用来存储一组对象,特别是当你需要唯一标识对象的时候.
这种做法有几个好处。首先，不能挂接一个类两次，也正因为如此，可以防止多次调用同一个对象的update()方法。
而且，不需要迭代访问或者搜集集合，就可以从集合中删除某个对象，这提高了运行效率。



